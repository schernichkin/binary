
==================== FINAL INTERFACE ====================
2019-05-22 17:18:49.433823631 UTC

interface binary-0.8.7.0-BLOwEKiKlD84pHPCNhnRK5:Data.Binary.Get.Internal 8065
  interface hash: 9f19ce738fe29c0f8ec9e06ea5d968d7
  ABI hash: 72d9f9f5cb4680e87b57f70e12a256ec
  export-list hash: 1715e4a790f17c7d3ecf70ee7ff47df1
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: c48181a165a3c9d643b6e80e6222deb1
  opt_hash: 5835274e0c52a5d281a4b935bfdb5c93
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Binary.Get.Internal.bytesRead
  Data.Binary.Get.Internal.ensureN
  Data.Binary.Get.Internal.failOnEOF
  Data.Binary.Get.Internal.get
  Data.Binary.Get.Internal.getByteString
  Data.Binary.Get.Internal.getBytes
  Data.Binary.Get.Internal.isEmpty
  Data.Binary.Get.Internal.isolate
  Data.Binary.Get.Internal.label
  Data.Binary.Get.Internal.lookAhead
  Data.Binary.Get.Internal.lookAheadE
  Data.Binary.Get.Internal.lookAheadM
  Data.Binary.Get.Internal.put
  Data.Binary.Get.Internal.readN
  Data.Binary.Get.Internal.readNWith
  Data.Binary.Get.Internal.remaining
  Data.Binary.Get.Internal.runGetIncremental
  Data.Binary.Get.Internal.withInputChunks
  Data.Binary.Get.Internal.Consume
  Data.Binary.Get.Internal.Decoder{Data.Binary.Get.Internal.BytesRead Data.Binary.Get.Internal.Done Data.Binary.Get.Internal.Fail Data.Binary.Get.Internal.Partial}
  Data.Binary.Get.Internal.Get{runCont}
module dependencies: Data.Binary.Internal
package dependencies: array-0.5.3.0 base-4.12.0.0
                      bytestring-0.10.8.2 deepseq-1.4.4.0 ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Control.Applicative 2ae514eb141d45774730765c61bb41c0
import  -/  base-4.12.0.0:Control.Monad 07eaec7fd256019b318d048d00f45b1c
import  -/  base-4.12.0.0:Control.Monad.Fail e3390d20cbc1146ebe051d327f964e5d
import  -/  base-4.12.0.0:Data.Either 423bee738f25e5ee983d072216009be8
import  -/  base-4.12.0.0:Data.Functor 069b2025a03e32fd228e74a86a58a075
import  -/  base-4.12.0.0:Data.Maybe 9b76a39e833465c3c5b3c078b431417f
import  -/  base-4.12.0.0:Foreign 194166dc1cce29a58ee017ed45b6c1fb
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Err ea5e313ef4146b40b5d8b27aa168e736
import  -/  base-4.12.0.0:GHC.Int 75a738083d98da9ebef0ff75df759462
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Ptr 68f634dc6eacf2af10dbc7ca1b1e41cb
import  -/  base-4.12.0.0:GHC.Real af2b985dd29515c375fb78b2c9298d42
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  Data.Binary.Internal 090186753e4cf387b1cf0176d283c9f3
  exports: e0c535d6514578e00f1d844344e40212
import  -/  bytestring-0.10.8.2:Data.ByteString fd8cecf441c361eb2e989315be3b33ab
import  -/  bytestring-0.10.8.2:Data.ByteString.Internal f8067c0775041a7adb8f53745475ed88
import  -/  bytestring-0.10.8.2:Data.ByteString.Unsafe 776fbb495c4caeeff10435741858143b
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
addDependentFile "/home/schernichkin/.stack/programs/x86_64-linux/ghc-8.6.5/lib/ghc-8.6.5/include/ghcversion.h" 43db44f9bb88490c2fa995e5f5ec33f2
addDependentFile ".stack-work/dist/x86_64-linux/Cabal-2.4.0.1/build/autogen/cabal_macros.h" e6f1f8b8bb6582b087a6681896f0d62a
addDependentFile "/usr/include/stdc-predef.h" b11071912035aeb144fe65c00cfe2168
a186c9537e26c2f269fcb2c351eb0f38
  $fAlternativeGet ::
    GHC.Base.Alternative Data.Binary.Get.Internal.Get
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Data.Binary.Get.Internal.Get
                  Data.Binary.Get.Internal.$fApplicativeGet
                  Data.Binary.Get.Internal.$fAlternativeGet_$cempty
                  Data.Binary.Get.Internal.$fAlternativeGet_$c<|>
                  Data.Binary.Get.Internal.$fAlternativeGet_$csome
                  Data.Binary.Get.Internal.$fAlternativeGet_$cmany -}
a186c9537e26c2f269fcb2c351eb0f38
  $fAlternativeGet_$c<|> ::
    Data.Binary.Get.Internal.Get a
    -> Data.Binary.Get.Internal.Get a -> Data.Binary.Get.Internal.Get a
  {- Arity: 4,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(C1(U))><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a ->
                 let {
                   loc :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b ->
                        GHC.CString.unpackFoldrCString#
                          @ b
                          "binary-0.8.7.0-BLOwEKiKlD84pHPCNhnRK5"#)
                 } in
                 let {
                   loc1 :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b ->
                        GHC.CString.unpackFoldrCString# @ b "Data.Binary.Get.Internal"#)
                 } in
                 let {
                   loc2 :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b ->
                        GHC.CString.unpackFoldrCString#
                          @ b
                          "src/Data/Binary/Get/Internal.hs"#)
                 } in
                 let {
                   loc3 :: GHC.Types.Int = GHC.Types.I# 276#
                 } in
                 let {
                   loc4 :: GHC.Types.Int = GHC.Types.I# 12#
                 } in
                 let {
                   loc5 :: GHC.Types.Int = GHC.Types.I# 276#
                 } in
                 let {
                   loc6 :: GHC.Types.Int = GHC.Types.I# 38#
                 } in
                 let {
                   $dIP :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b -> GHC.CString.unpackFoldrCString# @ b "error"#)
                 } in
                 let {
                   $dIP1 :: GHC.Stack.Types.SrcLoc
                   = GHC.Stack.Types.SrcLoc loc loc1 loc2 loc3 loc4 loc5 loc6
                 } in
                 let {
                   $dIP2 :: GHC.Stack.Types.CallStack
                   = GHC.Stack.Types.PushCallStack
                       $dIP
                       $dIP1
                       GHC.Stack.Types.EmptyCallStack
                 } in
                 (\ (f :: Data.Binary.Get.Internal.Get a)
                    (g :: Data.Binary.Get.Internal.Get a)
                    @ r
                    (i :: Data.ByteString.Internal.ByteString)
                    (ks :: Data.Binary.Get.Internal.Success a r) ->
                  let {
                    ks1 :: Data.Binary.Get.Internal.Success
                             (Data.Binary.Get.Internal.Decoder a,
                              [Data.ByteString.Internal.ByteString])
                             r
                      {- Arity: 2 -}
                    = \ (i' :: Data.ByteString.Internal.ByteString)
                        (a1 :: (Data.Binary.Get.Internal.Decoder a,
                                [Data.ByteString.Internal.ByteString])) ->
                      case a1 of wild { (,) decoder bs ->
                      case decoder of wild1 {
                        DEFAULT
                        -> case GHC.Err.error
                                  @ 'GHC.Types.LiftedRep
                                  @ (Data.Binary.Get.Internal.Get a)
                                  $dIP2
                                    `cast`
                                  (Sym (GHC.Classes.N:IP[0]
                                            <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                                  (GHC.Base.build
                                     @ GHC.Types.Char
                                     (\ @ b ->
                                      GHC.CString.unpackFoldrCString# @ b "Binary: impossible"#))
                           ret_ty (Data.Binary.Get.Internal.Decoder r)
                           of {}
                        Data.Binary.Get.Internal.Fail ds ds1
                        -> case bs of wild2 {
                             [] -> g `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R) @ r i' ks
                             : ipv ipv1
                             -> g `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                                  @ r
                                  (Data.ByteString.concat
                                     (GHC.Types.: @ Data.ByteString.Internal.ByteString i' wild2))
                                  ks }
                        Data.Binary.Get.Internal.Done inp x -> ks inp x } }
                  } in
                  letrec {
                    go :: [Data.ByteString.Internal.ByteString]
                          -> Data.Binary.Get.Internal.Decoder a
                          -> Data.Binary.Get.Internal.Decoder r
                      {- Arity: 2 -}
                    = \ (acc :: [Data.ByteString.Internal.ByteString])
                        (r1 :: Data.Binary.Get.Internal.Decoder a) ->
                      case acc of acc1 { DEFAULT ->
                      case r1 of wild {
                        Data.Binary.Get.Internal.Fail inp' s
                        -> ks1
                             i
                             (Data.Binary.Get.Internal.$WFail @ a inp' s,
                              GHC.List.reverse1
                                @ Data.ByteString.Internal.ByteString
                                acc1
                                (GHC.Types.[] @ Data.ByteString.Internal.ByteString))
                        Data.Binary.Get.Internal.Partial k
                        -> Data.Binary.Get.Internal.Partial
                             @ r
                             (\ (minp :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString) ->
                              go
                                (case minp of wild1 {
                                   GHC.Maybe.Nothing -> acc1
                                   GHC.Maybe.Just x
                                   -> GHC.Types.: @ Data.ByteString.Internal.ByteString x acc1 })
                                (k minp))
                        Data.Binary.Get.Internal.Done inp' a1
                        -> ks1
                             i
                             (Data.Binary.Get.Internal.$WDone @ a inp' a1,
                              GHC.List.reverse1
                                @ Data.ByteString.Internal.ByteString
                                acc1
                                (GHC.Types.[] @ Data.ByteString.Internal.ByteString))
                        Data.Binary.Get.Internal.BytesRead dt k
                        -> Data.Binary.Get.Internal.$WBytesRead
                             @ r
                             (GHC.Int.I64# dt)
                             (\ (x :: GHC.Int.Int64) -> go acc1 (k x)) } }
                  } in
                  go
                    (GHC.Types.[] @ Data.ByteString.Internal.ByteString)
                    (f `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                       @ a
                       i
                       (Data.Binary.Get.Internal.$WDone @ a)))
                   `cast`
                 (<Data.Binary.Get.Internal.Get a>_R
                  ->_R <Data.Binary.Get.Internal.Get a>_R
                  ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R))) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fAlternativeGet_$cempty :: Data.Binary.Get.Internal.Get a
  {- Arity: 2, Strictness: <S,1*U(U,U,U,U)><L,A>m1,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ a
                   @ r
                   (inp :: Data.ByteString.Internal.ByteString)
                   (_ks :: Data.Binary.Get.Internal.Success a r) ->
                 Data.Binary.Get.Internal.$WFail
                   @ r
                   inp
                   (GHC.Base.build
                      @ GHC.Types.Char
                      (\ @ b ->
                       GHC.CString.unpackFoldrCString#
                         @ b
                         "Data.Binary.Get(Alternative).empty"#)))
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R)) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fAlternativeGet_$cmany ::
    Data.Binary.Get.Internal.Get a -> Data.Binary.Get.Internal.Get [a]
  {- Arity: 3, Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))>,
     Inline: (sat-args=1),
     Unfolding(loop-breaker): InlineRule (1, False, False)
                              (\ @ a (p :: Data.Binary.Get.Internal.Get a) ->
                               let {
                                 loc :: [GHC.Types.Char]
                                 = GHC.Base.build
                                     @ GHC.Types.Char
                                     (\ @ b ->
                                      GHC.CString.unpackFoldrCString#
                                        @ b
                                        "binary-0.8.7.0-BLOwEKiKlD84pHPCNhnRK5"#)
                               } in
                               let {
                                 loc1 :: [GHC.Types.Char]
                                 = GHC.Base.build
                                     @ GHC.Types.Char
                                     (\ @ b ->
                                      GHC.CString.unpackFoldrCString#
                                        @ b
                                        "Data.Binary.Get.Internal"#)
                               } in
                               let {
                                 loc2 :: [GHC.Types.Char]
                                 = GHC.Base.build
                                     @ GHC.Types.Char
                                     (\ @ b ->
                                      GHC.CString.unpackFoldrCString#
                                        @ b
                                        "src/Data/Binary/Get/Internal.hs"#)
                               } in
                               let {
                                 loc3 :: GHC.Types.Int = GHC.Types.I# 276#
                               } in
                               let {
                                 loc4 :: GHC.Types.Int = GHC.Types.I# 12#
                               } in
                               let {
                                 loc5 :: GHC.Types.Int = GHC.Types.I# 276#
                               } in
                               let {
                                 loc6 :: GHC.Types.Int = GHC.Types.I# 38#
                               } in
                               let {
                                 $dIP :: [GHC.Types.Char]
                                 = GHC.Base.build
                                     @ GHC.Types.Char
                                     (\ @ b -> GHC.CString.unpackFoldrCString# @ b "error"#)
                               } in
                               let {
                                 $dIP1 :: GHC.Stack.Types.SrcLoc
                                 = GHC.Stack.Types.SrcLoc loc loc1 loc2 loc3 loc4 loc5 loc6
                               } in
                               let {
                                 $dIP2 :: GHC.Stack.Types.CallStack
                                 = GHC.Stack.Types.PushCallStack
                                     $dIP
                                     $dIP1
                                     GHC.Stack.Types.EmptyCallStack
                               } in
                               (\ @ r
                                  (i :: Data.ByteString.Internal.ByteString)
                                  (ks :: Data.Binary.Get.Internal.Success [a] r) ->
                                let {
                                  ks1 :: Data.Binary.Get.Internal.Success (GHC.Maybe.Maybe a) r
                                    {- Arity: 2 -}
                                  = \ (i' :: Data.ByteString.Internal.ByteString)
                                      (a1 :: GHC.Maybe.Maybe a) ->
                                    case a1 of wild {
                                      GHC.Maybe.Nothing
                                      -> (Data.Binary.Get.Internal.$fAlternativeGet_$cpure
                                            @ [a]
                                            (GHC.Types.[] @ a))
                                           `cast`
                                         (Data.Binary.Get.Internal.N:Get[0] <[a]>_R)
                                           @ r
                                           i'
                                           ks
                                      GHC.Maybe.Just x
                                      -> (Data.Binary.Get.Internal.$fAlternativeGet_$cmany @ a p)
                                           `cast`
                                         (Data.Binary.Get.Internal.N:Get[0] <[a]>_R)
                                           @ r
                                           i'
                                           (\ (i'1 :: Data.ByteString.Internal.ByteString)
                                              (a2 :: [a]) ->
                                            ks i'1 (GHC.Types.: @ a x a2)) }
                                } in
                                let {
                                  ks2 :: Data.Binary.Get.Internal.Success
                                           (Data.Binary.Get.Internal.Decoder (GHC.Maybe.Maybe a),
                                            [Data.ByteString.Internal.ByteString])
                                           r
                                    {- Arity: 2 -}
                                  = \ (i' :: Data.ByteString.Internal.ByteString)
                                      (a1 :: (Data.Binary.Get.Internal.Decoder (GHC.Maybe.Maybe a),
                                              [Data.ByteString.Internal.ByteString])) ->
                                    case a1 of wild { (,) decoder bs ->
                                    case decoder of wild1 {
                                      DEFAULT
                                      -> case GHC.Err.error
                                                @ 'GHC.Types.LiftedRep
                                                @ (Data.Binary.Get.Internal.Get (GHC.Maybe.Maybe a))
                                                $dIP2
                                                  `cast`
                                                (Sym (GHC.Classes.N:IP[0]
                                                          <"callStack">_N
                                                          <GHC.Stack.Types.CallStack>_N))
                                                (GHC.Base.build
                                                   @ GHC.Types.Char
                                                   (\ @ b ->
                                                    GHC.CString.unpackFoldrCString#
                                                      @ b
                                                      "Binary: impossible"#))
                                         ret_ty (Data.Binary.Get.Internal.Decoder r)
                                         of {}
                                      Data.Binary.Get.Internal.Fail ds ds1
                                      -> case bs of wild2 {
                                           []
                                           -> (Data.Binary.Get.Internal.$fAlternativeGet_$cpure
                                                 @ (GHC.Maybe.Maybe a)
                                                 (GHC.Maybe.Nothing @ a))
                                                `cast`
                                              (Data.Binary.Get.Internal.N:Get[0]
                                                   <GHC.Maybe.Maybe a>_R)
                                                @ r
                                                i'
                                                ks1
                                           : ipv ipv1
                                           -> (Data.Binary.Get.Internal.$fAlternativeGet_$cpure
                                                 @ (GHC.Maybe.Maybe a)
                                                 (GHC.Maybe.Nothing @ a))
                                                `cast`
                                              (Data.Binary.Get.Internal.N:Get[0]
                                                   <GHC.Maybe.Maybe a>_R)
                                                @ r
                                                (Data.ByteString.concat
                                                   (GHC.Types.:
                                                      @ Data.ByteString.Internal.ByteString
                                                      i'
                                                      wild2))
                                                ks1 }
                                      Data.Binary.Get.Internal.Done inp x -> ks1 inp x } }
                                } in
                                letrec {
                                  go :: [Data.ByteString.Internal.ByteString]
                                        -> Data.Binary.Get.Internal.Decoder (GHC.Maybe.Maybe a)
                                        -> Data.Binary.Get.Internal.Decoder r
                                    {- Arity: 2 -}
                                  = \ (acc :: [Data.ByteString.Internal.ByteString])
                                      (r1 :: Data.Binary.Get.Internal.Decoder
                                               (GHC.Maybe.Maybe a)) ->
                                    case acc of acc1 { DEFAULT ->
                                    case r1 of wild {
                                      Data.Binary.Get.Internal.Fail inp' s
                                      -> ks2
                                           i
                                           (Data.Binary.Get.Internal.$WFail
                                              @ (GHC.Maybe.Maybe a)
                                              inp'
                                              s,
                                            GHC.List.reverse1
                                              @ Data.ByteString.Internal.ByteString
                                              acc1
                                              (GHC.Types.[] @ Data.ByteString.Internal.ByteString))
                                      Data.Binary.Get.Internal.Partial k
                                      -> Data.Binary.Get.Internal.Partial
                                           @ r
                                           (\ (minp :: GHC.Maybe.Maybe
                                                         Data.ByteString.Internal.ByteString) ->
                                            go
                                              (case minp of wild1 {
                                                 GHC.Maybe.Nothing -> acc1
                                                 GHC.Maybe.Just x
                                                 -> GHC.Types.:
                                                      @ Data.ByteString.Internal.ByteString
                                                      x
                                                      acc1 })
                                              (k minp))
                                      Data.Binary.Get.Internal.Done inp' a1
                                      -> ks2
                                           i
                                           (Data.Binary.Get.Internal.$WDone
                                              @ (GHC.Maybe.Maybe a)
                                              inp'
                                              a1,
                                            GHC.List.reverse1
                                              @ Data.ByteString.Internal.ByteString
                                              acc1
                                              (GHC.Types.[] @ Data.ByteString.Internal.ByteString))
                                      Data.Binary.Get.Internal.BytesRead dt k
                                      -> Data.Binary.Get.Internal.$WBytesRead
                                           @ r
                                           (GHC.Int.I64# dt)
                                           (\ (x :: GHC.Int.Int64) -> go acc1 (k x)) } }
                                } in
                                go
                                  (GHC.Types.[] @ Data.ByteString.Internal.ByteString)
                                  (p `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                                     @ (GHC.Maybe.Maybe a)
                                     i
                                     (\ (i' :: Data.ByteString.Internal.ByteString) (a1 :: a) ->
                                      Data.Binary.Get.Internal.$WDone
                                        @ (GHC.Maybe.Maybe a)
                                        i'
                                        (GHC.Maybe.Just @ a a1))))
                                 `cast`
                               (Sym (Data.Binary.Get.Internal.N:Get[0] <[a]>_R))) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fAlternativeGet_$cpure :: a -> Data.Binary.Get.Internal.Get a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,U><C(C(S)),1*C1(C1(U))>,
     Inline: [0] (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                (\ @ a
                   (x :: a)
                   @ r
                   (s :: Data.ByteString.Internal.ByteString)
                   (ks :: Data.Binary.Get.Internal.Success a r) ->
                 ks s x)
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R)) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fAlternativeGet_$csome ::
    Data.Binary.Get.Internal.Get a -> Data.Binary.Get.Internal.Get [a]
  {- Arity: 3, Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (p :: Data.Binary.Get.Internal.Get a) ->
                 Data.Binary.Get.Internal.apG
                   @ [a]
                   @ [a]
                   (\ @ r
                      (i :: Data.ByteString.Internal.ByteString)
                      (ks :: Data.Binary.Get.Internal.Success ([a] -> [a]) r) ->
                    p `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                      @ r
                      i
                      (\ (i' :: Data.ByteString.Internal.ByteString) (a1 :: a) ->
                       ks i' (GHC.Types.: @ a a1)))
                     `cast`
                   (Sym (Data.Binary.Get.Internal.N:Get[0] <[a] -> [a]>_R))
                   (Data.Binary.Get.Internal.$fAlternativeGet_$cmany @ a p)) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fApplicativeGet ::
    GHC.Base.Applicative Data.Binary.Get.Internal.Get
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Data.Binary.Get.Internal.Get
                  Data.Binary.Get.Internal.$fFunctorGet
                  Data.Binary.Get.Internal.$fAlternativeGet_$cpure
                  Data.Binary.Get.Internal.apG
                  Data.Binary.Get.Internal.$fApplicativeGet3
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Data.Binary.Get.Internal.Get a>_R
                   ->_R <Data.Binary.Get.Internal.Get b>_R
                   ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <c>_R))
                  Data.Binary.Get.Internal.$fApplicativeGet2
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Data.Binary.Get.Internal.Get a>_R
                   ->_R <Data.Binary.Get.Internal.Get b>_R
                   ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <b>_R))
                  Data.Binary.Get.Internal.$fApplicativeGet1
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Data.Binary.Get.Internal.Get a>_R
                   ->_R <Data.Binary.Get.Internal.Get b>_R
                   ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R)) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fApplicativeGet1 ::
    Data.Binary.Get.Internal.Get a
    -> Data.Binary.Get.Internal.Get b
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success a r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ a
                   @ b
                   (x :: Data.Binary.Get.Internal.Get a)
                   (eta :: Data.Binary.Get.Internal.Get b)
                   @ r
                   (eta1 :: Data.ByteString.Internal.ByteString)
                   (eta2 :: Data.Binary.Get.Internal.Success a r) ->
                 x `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                   @ r
                   eta1
                   (\ (i' :: Data.ByteString.Internal.ByteString) (a1 :: a) ->
                    eta `cast` (Data.Binary.Get.Internal.N:Get[0] <b>_R)
                      @ r
                      i'
                      (\ (i'1 :: Data.ByteString.Internal.ByteString) (a2 :: b) ->
                       eta2 i'1 a1))) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fApplicativeGet2 ::
    Data.Binary.Get.Internal.Get a
    -> Data.Binary.Get.Internal.Get b
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success b r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ a
                   @ b
                   (a1 :: Data.Binary.Get.Internal.Get a)
                   (a2 :: Data.Binary.Get.Internal.Get b)
                   @ r
                   (eta :: Data.ByteString.Internal.ByteString)
                   (eta1 :: Data.Binary.Get.Internal.Success b r) ->
                 let {
                   lvl13 :: Data.ByteString.Internal.ByteString
                            -> b -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 2, Strictness: <L,U><L,U> -}
                   = \ (i' :: Data.ByteString.Internal.ByteString) (a4 :: b) ->
                     eta1 i' a4
                 } in
                 a1 `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                   @ r
                   eta
                   (\ (i' :: Data.ByteString.Internal.ByteString) (a4 :: a) ->
                    a2 `cast` (Data.Binary.Get.Internal.N:Get[0] <b>_R)
                      @ r
                      i'
                      lvl13)) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fApplicativeGet3 ::
    (a -> b -> c)
    -> Data.Binary.Get.Internal.Get a
    -> Data.Binary.Get.Internal.Get b
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success c r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,C(C(U))><C(C(S)),1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (f1 :: a -> b -> c)
                   (x :: Data.Binary.Get.Internal.Get a)
                   (eta :: Data.Binary.Get.Internal.Get b)
                   @ r
                   (eta1 :: Data.ByteString.Internal.ByteString)
                   (eta2 :: Data.Binary.Get.Internal.Success c r) ->
                 x `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                   @ r
                   eta1
                   (\ (i' :: Data.ByteString.Internal.ByteString) (a1 :: a) ->
                    let {
                      a2 :: b -> c = f1 a1
                    } in
                    eta `cast` (Data.Binary.Get.Internal.N:Get[0] <b>_R)
                      @ r
                      i'
                      (\ (i'1 :: Data.ByteString.Internal.ByteString) (a3 :: b) ->
                       eta2 i'1 (a2 a3)))) -}
a8bf888f063389d343f398bcd63cf8a2
  $fFunctorDecoder ::
    GHC.Base.Functor Data.Binary.Get.Internal.Decoder
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Data.Binary.Get.Internal.Decoder
                  Data.Binary.Get.Internal.$fFunctorDecoder_$cfmap
                  Data.Binary.Get.Internal.$fFunctorDecoder_$c<$ -}
a8bf888f063389d343f398bcd63cf8a2
  $fFunctorDecoder_$c<$ ::
    a
    -> Data.Binary.Get.Internal.Decoder b
    -> Data.Binary.Get.Internal.Decoder a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (x :: a) (eta :: Data.Binary.Get.Internal.Decoder b) ->
                 Data.Binary.Get.Internal.$fFunctorDecoder_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> x)
                   eta) -}
a8bf888f063389d343f398bcd63cf8a2
  $fFunctorDecoder_$cfmap ::
    (a -> b)
    -> Data.Binary.Get.Internal.Decoder a
    -> Data.Binary.Get.Internal.Decoder b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
a186c9537e26c2f269fcb2c351eb0f38
  $fFunctorGet :: GHC.Base.Functor Data.Binary.Get.Internal.Get
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Data.Binary.Get.Internal.Get
                  Data.Binary.Get.Internal.fmapG
                  Data.Binary.Get.Internal.$fFunctorGet1
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Data.Binary.Get.Internal.Get b>_R
                   ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R)) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fFunctorGet1 ::
    a
    -> Data.Binary.Get.Internal.Get b
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success a r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (x :: a)
                   (eta :: Data.Binary.Get.Internal.Get b)
                   @ r
                   (eta1 :: Data.ByteString.Internal.ByteString)
                   (eta2 :: Data.Binary.Get.Internal.Success a r) ->
                 eta `cast` (Data.Binary.Get.Internal.N:Get[0] <b>_R)
                   @ r
                   eta1
                   (\ (i' :: Data.ByteString.Internal.ByteString) (a1 :: b) ->
                    eta2 i' x)) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fMonadFailGet ::
    Control.Monad.Fail.MonadFail Data.Binary.Get.Internal.Get
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Data.Binary.Get.Internal.Get
                  Data.Binary.Get.Internal.$fMonadGet
                  Data.Binary.Get.Internal.$fMonadFailGet1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Base.String>_R
                   ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R)) -}
263bd89bc5588ddba8226a0dfb4bda2d
  $fMonadFailGet1 ::
    GHC.Base.String
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success a r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,U><L,A>m1,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   (str2 :: GHC.Base.String)
                   @ r
                   (i :: Data.ByteString.Internal.ByteString)
                   (_ks :: Data.Binary.Get.Internal.Success a r) ->
                 Data.Binary.Get.Internal.$WFail @ r i str2) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fMonadGet :: GHC.Base.Monad Data.Binary.Get.Internal.Get
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Data.Binary.Get.Internal.Get
                  Data.Binary.Get.Internal.$fApplicativeGet
                  Data.Binary.Get.Internal.bindG
                  Data.Binary.Get.Internal.$fMonadGet_$c>>
                  Data.Binary.Get.Internal.$fAlternativeGet_$cpure
                  Data.Binary.Get.Internal.$fMonadFailGet1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Base.String>_R
                   ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R)) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fMonadGet_$c>> ::
    Data.Binary.Get.Internal.Get a
    -> Data.Binary.Get.Internal.Get b -> Data.Binary.Get.Internal.Get b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(C1(U))><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Data.Binary.Get.Internal.Get a)
                   (k :: Data.Binary.Get.Internal.Get b)
                   @ r
                   (i :: Data.ByteString.Internal.ByteString)
                   (ks :: Data.Binary.Get.Internal.Success b r) ->
                 m1 `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                   @ r
                   i
                   (\ (i' :: Data.ByteString.Internal.ByteString) (a1 :: a) ->
                    k `cast` (Data.Binary.Get.Internal.N:Get[0] <b>_R) @ r i' ks))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Data.Binary.Get.Internal.Get a>_R
                 ->_R <Data.Binary.Get.Internal.Get b>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <b>_R)) -}
a186c9537e26c2f269fcb2c351eb0f38
  $fMonadPlusGet :: GHC.Base.MonadPlus Data.Binary.Get.Internal.Get
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Data.Binary.Get.Internal.Get
                  Data.Binary.Get.Internal.$fAlternativeGet
                  Data.Binary.Get.Internal.$fMonadGet
                  Data.Binary.Get.Internal.$fAlternativeGet_$cempty
                  Data.Binary.Get.Internal.$fAlternativeGet_$c<|> -}
a8bf888f063389d343f398bcd63cf8a2
  $fShowDecoder ::
    GHC.Show.Show a =>
    GHC.Show.Show (Data.Binary.Get.Internal.Decoder a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,C(U),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Data.Binary.Get.Internal.Decoder a)
                  (Data.Binary.Get.Internal.$fShowDecoder_$cshowsPrec @ a v)
                  (Data.Binary.Get.Internal.$fShowDecoder_$cshow @ a v)
                  (Data.Binary.Get.Internal.$fShowDecoder_$cshowList @ a v) -}
c9d7edda6b452ede8ff913d175e49ea5
  $fShowDecoder1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Data.Binary.Get.Internal.$fShowDecoder2) -}
658415d5afd1551830baa9ab63a44618
  $fShowDecoder2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BytesRead"#) -}
6ee641a13142a64ab2f00bc9e7f770fa
  $fShowDecoder3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Done: "#) -}
e83f60e21ebbad89a014d462e5a37492
  $fShowDecoder4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Data.Binary.Get.Internal.$fShowDecoder5) -}
8e48e6a9e990070e7bb8b2afd035b370
  $fShowDecoder5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Partial _"#) -}
6233def4c2fcd6791b0518687e425036
  $fShowDecoder6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Fail: "#) -}
a8bf888f063389d343f398bcd63cf8a2
  $fShowDecoder_$cshow ::
    GHC.Show.Show a =>
    Data.Binary.Get.Internal.Decoder a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(A,1*C1(U),A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: Data.Binary.Get.Internal.Decoder a) ->
                 case ds of wild {
                   Data.Binary.Get.Internal.Fail ds1 msg
                   -> GHC.CString.unpackAppendCString#
                        Data.Binary.Get.Internal.$fShowDecoder6
                        msg
                   Data.Binary.Get.Internal.Partial ds1
                   -> Data.Binary.Get.Internal.$fShowDecoder4
                   Data.Binary.Get.Internal.Done ds1 a1
                   -> GHC.CString.unpackAppendCString#
                        Data.Binary.Get.Internal.$fShowDecoder3
                        (GHC.Show.show @ a $dShow a1)
                   Data.Binary.Get.Internal.BytesRead dt ds1
                   -> Data.Binary.Get.Internal.$fShowDecoder1 }) -}
a8bf888f063389d343f398bcd63cf8a2
  $fShowDecoder_$cshowList ::
    GHC.Show.Show a =>
    [Data.Binary.Get.Internal.Decoder a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,C(U),A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Data.Binary.Get.Internal.Decoder a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Binary.Get.Internal.Decoder a)
                   (\ (x :: Data.Binary.Get.Internal.Decoder a)
                      (s1 :: GHC.Base.String)[OneShot] ->
                    case x of wild {
                      Data.Binary.Get.Internal.Fail ds msg
                      -> GHC.CString.unpackAppendCString#
                           Data.Binary.Get.Internal.$fShowDecoder6
                           (GHC.Base.++ @ GHC.Types.Char msg s1)
                      Data.Binary.Get.Internal.Partial ds
                      -> GHC.Base.++
                           @ GHC.Types.Char
                           Data.Binary.Get.Internal.$fShowDecoder4
                           s1
                      Data.Binary.Get.Internal.Done ds a1
                      -> GHC.CString.unpackAppendCString#
                           Data.Binary.Get.Internal.$fShowDecoder3
                           (GHC.Base.++ @ GHC.Types.Char (GHC.Show.show @ a $dShow a1) s1)
                      Data.Binary.Get.Internal.BytesRead dt ds
                      -> GHC.Base.++
                           @ GHC.Types.Char
                           Data.Binary.Get.Internal.$fShowDecoder1
                           s1 })
                   ls
                   s) -}
a8bf888f063389d343f398bcd63cf8a2
  $fShowDecoder_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int
    -> Data.Binary.Get.Internal.Decoder a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,1*U(A,1*C1(U),A)><L,A><S,1*U><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Data.Binary.Get.Internal.Decoder a)
                   (w3 :: GHC.Base.String) ->
                 Data.Binary.Get.Internal.$w$cshowsPrec @ a w w2 w3) -}
24dd65215068c0a56cab88368aa39abe
  $tc'BytesRead :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12325702020380439130##
                   2954535524427172474##
                   Data.Binary.Get.Internal.$trModule
                   Data.Binary.Get.Internal.$tc'BytesRead2
                   1#
                   Data.Binary.Get.Internal.$tc'BytesRead1) -}
b35475af5246b45fbc18c2d85a4a911c
  $tc'BytesRead1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
200fb400229ad514a9dd8feecd9f001b
  $tc'BytesRead2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Data.Binary.Get.Internal.$tc'BytesRead3) -}
dc924f0c5eef01a52d6c31a6d7ab114a
  $tc'BytesRead3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BytesRead"#) -}
2a487c069a98c1b3a9e1681403649c85
  $tc'Done :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16134382132603625262##
                   13784388590398315229##
                   Data.Binary.Get.Internal.$trModule
                   Data.Binary.Get.Internal.$tc'Done2
                   1#
                   Data.Binary.Get.Internal.$tc'Done1) -}
f3fd4e694817410f641fbe06f0edafe3
  $tc'Done1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5e6244970e4ee49259452976b54f2959
  $tc'Done2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Data.Binary.Get.Internal.$tc'Done3) -}
2d5f587b595dbb68bdb1fcd40fbf7eed
  $tc'Done3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Done"#) -}
113ef8a4492d5f9ae550ff207ab17799
  $tc'Fail :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13105609961551097194##
                   1554934144142252745##
                   Data.Binary.Get.Internal.$trModule
                   Data.Binary.Get.Internal.$tc'Fail2
                   1#
                   Data.Binary.Get.Internal.$tc'Fail1) -}
78e0e4ba99c40f52edfd01b30ac15893
  $tc'Fail1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
53e53445fd32e87c39a6c3eed3c6f628
  $tc'Fail2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Data.Binary.Get.Internal.$tc'Fail3) -}
fd86de32bf5ec08b7f7f2b579a2ca369
  $tc'Fail3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Fail"#) -}
abe03947a4df1845ebbb0a8e089ae47b
  $tc'Partial :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15173105408255044369##
                   13371422236140122691##
                   Data.Binary.Get.Internal.$trModule
                   Data.Binary.Get.Internal.$tc'Partial2
                   1#
                   Data.Binary.Get.Internal.$tc'Partial1) -}
8e905dce75d8c6f3a3b5a6f197fa3f70
  $tc'Partial1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cf50d5a827ce6522d1a5820404105a88
  $tc'Partial2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Data.Binary.Get.Internal.$tc'Partial3) -}
687005a387d8d03702592e5fc7cabfd0
  $tc'Partial3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Partial"#) -}
a361af4dfd5b92a3397901ac1a454852
  $tcDecoder :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6456921530904996345##
                   9437288741564578433##
                   Data.Binary.Get.Internal.$trModule
                   Data.Binary.Get.Internal.$tcDecoder1
                   0#
                   GHC.Types.krep$*Arr*) -}
28ce8750480b183096f18ee1b66aad8a
  $tcDecoder1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Data.Binary.Get.Internal.$tcDecoder2) -}
53571f51ac428b5c49695dbc37305810
  $tcDecoder2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Decoder"#) -}
218176f4c887fc478fd51b43b7e833b9
  $tcGet :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6903038902197456777##
                   388751050352275202##
                   Data.Binary.Get.Internal.$trModule
                   Data.Binary.Get.Internal.$tcGet1
                   0#
                   GHC.Types.krep$*Arr*) -}
0cd6748e1ac728d5990cdd11414db717
  $tcGet1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Data.Binary.Get.Internal.$tcGet2) -}
077d4c40e92a55a7dec62e858e914874
  $tcGet2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Get"#) -}
2aa66c1a01691bb13f877d2734f898e1
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Binary.Get.Internal.$trModule3
                   Data.Binary.Get.Internal.$trModule1) -}
a735aaab328292f0d5214e61c0617149
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Data.Binary.Get.Internal.$trModule2) -}
bb6d892f5ff5431cca4556f826493a45
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Data.Binary.Get.Internal"#) -}
3b0e3b9791bf2b6ebe37f1001fceaea7
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Data.Binary.Get.Internal.$trModule4) -}
acf71a257d0c053afbbc1d0fc3a6ae44
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("binary-0.8.7.0-BLOwEKiKlD84pHPCNhnRK5"#) -}
a8bf888f063389d343f398bcd63cf8a2
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    Data.Binary.Get.Internal.Decoder a
    -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 3, Strictness: <L,1*U(A,1*C1(U),A)><S,1*U><L,1*U>,
     Inline: [2],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: Data.Binary.Get.Internal.Decoder a)
                   (w2 :: GHC.Base.String) ->
                 case w1 of wild {
                   Data.Binary.Get.Internal.Fail ds msg
                   -> GHC.CString.unpackAppendCString#
                        Data.Binary.Get.Internal.$fShowDecoder6
                        (GHC.Base.++ @ GHC.Types.Char msg w2)
                   Data.Binary.Get.Internal.Partial ds
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Binary.Get.Internal.$fShowDecoder4
                        w2
                   Data.Binary.Get.Internal.Done ds a1
                   -> GHC.CString.unpackAppendCString#
                        Data.Binary.Get.Internal.$fShowDecoder3
                        (GHC.Base.++ @ GHC.Types.Char (GHC.Show.show @ a w a1) w2)
                   Data.Binary.Get.Internal.BytesRead dt ds
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Binary.Get.Internal.$fShowDecoder1
                        w2 }) -}
075bb7f3c54aff19d77fa8e048f4041c
  $wisEmpty ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success GHC.Types.Bool r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,C(C1(U))>,
     Inline: [2],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success GHC.Types.Bool r) ->
                 let {
                   wild :: Data.ByteString.Internal.ByteString
                   = Data.ByteString.Internal.PS ww ww1 ww2 ww3
                 } in
                 case GHC.Prim.<=# ww3 0# of lwild {
                   DEFAULT -> w wild GHC.Types.False
                   1#
                   -> let {
                        kf :: Data.Binary.Get.Internal.Decoder r = w wild GHC.Types.True
                      } in
                      letrec {
                        loop :: Data.Binary.Get.Internal.Decoder r
                        = Data.Binary.Get.Internal.Partial @ r loop1
                        loop1 :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString
                                 -> Data.Binary.Get.Internal.Decoder r
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (sm :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString) ->
                          case sm of wild1 {
                            GHC.Maybe.Nothing -> kf
                            GHC.Maybe.Just s
                            -> case s of wild2 { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                               case GHC.Prim.<=# dt3 0# of lwild1 {
                                 DEFAULT
                                 -> w (GHC.Base.mappend
                                         @ Data.ByteString.Internal.ByteString
                                         Data.ByteString.Internal.$fMonoidByteString
                                         wild
                                         wild2)
                                      GHC.Types.False
                                 1# -> loop } } }
                      } in
                      loop }) -}
0d9d6c446618a662e04fe382f80ee8e0
  $wisolate ::
    GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Get a -> Data.Binary.Get.Internal.Get a
  {- Arity: 2, Strictness: <S,U><L,1*C1(C1(U))>, Inline: [2] -}
9dd97f1f0e71fc78ad3a8787b0f7a1a3
  type Consume s =
    s
    -> Data.ByteString.Internal.ByteString
    -> Data.Either.Either
         s
         (Data.ByteString.Internal.ByteString,
          Data.ByteString.Internal.ByteString)
a8bf888f063389d343f398bcd63cf8a2
  data Decoder a
    = Fail !Data.ByteString.Internal.ByteString GHC.Base.String
    | Partial (GHC.Maybe.Maybe Data.ByteString.Internal.ByteString
               -> Data.Binary.Get.Internal.Decoder a)
    | Done !Data.ByteString.Internal.ByteString a
    | BytesRead {-# UNPACK #-}GHC.Int.Int64
                (GHC.Int.Int64 -> Data.Binary.Get.Internal.Decoder a)
a186c9537e26c2f269fcb2c351eb0f38
  newtype Get a
    = C {runCont :: forall r.
                    Data.ByteString.Internal.ByteString
                    -> Data.Binary.Get.Internal.Success a r
                    -> Data.Binary.Get.Internal.Decoder r}
49d04870866437c9da61e9c37863ba58
  type Success a r =
    Data.ByteString.Internal.ByteString
    -> a -> Data.Binary.Get.Internal.Decoder r
a186c9537e26c2f269fcb2c351eb0f38
  apG ::
    Data.Binary.Get.Internal.Get (a -> b)
    -> Data.Binary.Get.Internal.Get a -> Data.Binary.Get.Internal.Get b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))>,
     Inline: [0] (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (d :: Data.Binary.Get.Internal.Get (a -> b))
                   (e :: Data.Binary.Get.Internal.Get a)
                   @ r
                   (i :: Data.ByteString.Internal.ByteString)
                   (ks :: Data.Binary.Get.Internal.Success b r) ->
                 d `cast` (Data.Binary.Get.Internal.N:Get[0] <a -> b>_R)
                   @ r
                   i
                   (\ (i' :: Data.ByteString.Internal.ByteString) (a1 :: a -> b) ->
                    e `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                      @ r
                      i'
                      (\ (i'1 :: Data.ByteString.Internal.ByteString) (a2 :: a) ->
                       ks i'1 (a1 a2))))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Data.Binary.Get.Internal.Get (a -> b)>_R
                 ->_R <Data.Binary.Get.Internal.Get a>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <b>_R)) -}
a186c9537e26c2f269fcb2c351eb0f38
  bindG ::
    Data.Binary.Get.Internal.Get a
    -> (a -> Data.Binary.Get.Internal.Get b)
    -> Data.Binary.Get.Internal.Get b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(C1(C1(U)))><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (ds :: Data.Binary.Get.Internal.Get a)
                   (f :: a -> Data.Binary.Get.Internal.Get b)
                   @ r
                   (i :: Data.ByteString.Internal.ByteString)
                   (ks :: Data.Binary.Get.Internal.Success b r) ->
                 ds `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                   @ r
                   i
                   (\ (i' :: Data.ByteString.Internal.ByteString) (a1 :: a) ->
                    (f a1) `cast` (Data.Binary.Get.Internal.N:Get[0] <b>_R) @ r i' ks))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Data.Binary.Get.Internal.Get a>_R
                 ->_R <a -> Data.Binary.Get.Internal.Get b>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <b>_R)) -}
6196e8dadce11105268b40093bb2e330
  bytesRead :: Data.Binary.Get.Internal.Get GHC.Int.Int64
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLS),1*U(U,U,U,U)><L,1*C1(U)>m4,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.bytesRead1
                  `cast`
                (Sym (Data.Binary.Get.Internal.N:Get[0] <GHC.Int.Int64>_R)) -}
d9c71a84b9280f6f541df1b6e1885b85
  bytesRead1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success GHC.Int.Int64 r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLS),1*U(U,U,U,U)><L,1*C1(U)>m4,
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (inp :: Data.ByteString.Internal.ByteString)
                   (k :: Data.Binary.Get.Internal.Success GHC.Int.Int64 r) ->
                 case inp of wild { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                 Data.Binary.Get.Internal.BytesRead @ r dt3 (k wild) }) -}
a972388002415c32dd97c418fb80e77e
  ensureN :: GHC.Types.Int -> Data.Binary.Get.Internal.Get ()
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (n0 :: GHC.Types.Int) ->
                 case n0 of n1 { GHC.Types.I# ipv ->
                 let {
                   onFail :: forall a.
                             [Data.ByteString.Internal.ByteString]
                             -> forall r.
                                Data.ByteString.Internal.ByteString
                                -> Data.Binary.Get.Internal.Success a r
                                -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 3 -}
                   = \ @ a
                       (bss :: [Data.ByteString.Internal.ByteString])
                       @ r
                       (ds :: Data.ByteString.Internal.ByteString)
                       (ds1 :: Data.Binary.Get.Internal.Success a r) ->
                     Data.Binary.Get.Internal.$WFail
                       @ r
                       (Data.ByteString.concat bss)
                       (GHC.Base.build
                          @ GHC.Types.Char
                          (\ @ b -> GHC.CString.unpackFoldrCString# @ b "not enough bytes"#))
                 } in
                 let {
                   onSucc :: [Data.ByteString.Internal.ByteString]
                             -> Data.ByteString.Internal.ByteString
                     {- Arity: 1 -}
                   = \ (x :: [Data.ByteString.Internal.ByteString]) ->
                     Data.ByteString.concat
                       (GHC.List.dropWhile
                          @ Data.ByteString.Internal.ByteString
                          Data.ByteString.null
                          x)
                 } in
                 let {
                   enoughChunks :: GHC.Types.Int
                                   -> Data.ByteString.Internal.ByteString
                                   -> Data.Either.Either
                                        GHC.Types.Int
                                        (Data.ByteString.Internal.ByteString,
                                         Data.ByteString.Internal.ByteString)
                     {- Arity: 2 -}
                   = \ (n :: GHC.Types.Int)
                       (str2 :: Data.ByteString.Internal.ByteString) ->
                     case str2 of wild { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                     case GHC.Classes.geInt (GHC.Types.I# dt3) n of wild1 {
                       GHC.Types.False
                       -> Data.Either.Left
                            @ GHC.Types.Int
                            @ (Data.ByteString.Internal.ByteString,
                               Data.ByteString.Internal.ByteString)
                            (case n of wild2 { GHC.Types.I# x ->
                             GHC.Types.I# (GHC.Prim.-# x dt3) })
                       GHC.Types.True
                       -> Data.Either.Right
                            @ GHC.Types.Int
                            @ (Data.ByteString.Internal.ByteString,
                               Data.ByteString.Internal.ByteString)
                            (wild, Data.ByteString.empty) } }
                 } in
                 (\ @ r
                    (inp :: Data.ByteString.Internal.ByteString)
                    (ks :: Data.Binary.Get.Internal.Success () r) ->
                  case inp of wild { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                  case GHC.Classes.geInt (GHC.Types.I# dt3) n1 of wild1 {
                    GHC.Types.False
                    -> Data.Binary.Get.Internal.readN1
                         @ GHC.Types.Int
                         @ Data.ByteString.Internal.ByteString
                         n1
                         enoughChunks
                         onSucc
                         (onFail @ Data.ByteString.Internal.ByteString)
                           `cast`
                         (<[Data.ByteString.Internal.ByteString]>_R
                          ->_R Sym (Data.Binary.Get.Internal.N:Get[0]
                                        <Data.ByteString.Internal.ByteString>_R))
                         @ r
                         wild
                         (\ (i' :: Data.ByteString.Internal.ByteString)
                            (a :: Data.ByteString.Internal.ByteString) ->
                          ks a GHC.Tuple.())
                    GHC.Types.True -> ks wild GHC.Tuple.() } })
                   `cast`
                 (Sym (Data.Binary.Get.Internal.N:Get[0] <()>_R)) }) -}
fd90dccc5825300728033c7ec82cd4dc
  failOnEOF ::
    [Data.ByteString.Internal.ByteString]
    -> Data.Binary.Get.Internal.Get a
  {- Arity: 3, Strictness: <L,U><L,A><L,A>m1,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.failOnEOF1
                  `cast`
                (forall (a :: <*>_N).
                 <[Data.ByteString.Internal.ByteString]>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R)) -}
e8f482b3bf04ae128ef5bdf7fbafb06b
  failOnEOF1 ::
    [Data.ByteString.Internal.ByteString]
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success a r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 3, Strictness: <L,U><L,A><L,A>m1,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (bs :: [Data.ByteString.Internal.ByteString])
                   @ r
                   (ds :: Data.ByteString.Internal.ByteString)
                   (ds1 :: Data.Binary.Get.Internal.Success a r) ->
                 case Data.ByteString.concat
                        bs of dt { Data.ByteString.Internal.PS ipv ipv1 ipv2 ipv3 ->
                 Data.Binary.Get.Internal.Fail
                   @ r
                   dt
                   Data.Binary.Get.Internal.failOnEOF2 }) -}
10ccbe49c343c18d8b2a649035415bb4
  failOnEOF2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Data.Binary.Get.Internal.failOnEOF3) -}
906e9d783e47609c9a33071139923334
  failOnEOF3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("not enough bytes"#) -}
a186c9537e26c2f269fcb2c351eb0f38
  fmapG ::
    (a -> b)
    -> Data.Binary.Get.Internal.Get a -> Data.Binary.Get.Internal.Get b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f :: a -> b)
                   (m :: Data.Binary.Get.Internal.Get a)
                   @ r
                   (i :: Data.ByteString.Internal.ByteString)
                   (ks :: Data.Binary.Get.Internal.Success b r) ->
                 m `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                   @ r
                   i
                   (\ (i' :: Data.ByteString.Internal.ByteString) (a1 :: a) ->
                    ks i' (f a1)))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Data.Binary.Get.Internal.Get a>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <b>_R)) -}
74854768380039deb3d6dd0108f9abb9
  get ::
    Data.Binary.Get.Internal.Get Data.ByteString.Internal.ByteString
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(C(S)),1*C1(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.get1
                  `cast`
                (Sym (Data.Binary.Get.Internal.N:Get[0]
                          <Data.ByteString.Internal.ByteString>_R)) -}
8a63d6a98ea97f4f31614b53750b1a8c
  get1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success
         Data.ByteString.Internal.ByteString r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(C(S)),1*C1(C1(U))>,
     Unfolding: InlineRule (2, True, True)
                (\ @ r
                   (inp :: Data.ByteString.Internal.ByteString)
                   (ks :: Data.Binary.Get.Internal.Success
                            Data.ByteString.Internal.ByteString r) ->
                 ks inp inp) -}
c1d082dd6a7fcc9d5e7e75223e285c02
  getByteString ::
    GHC.Types.Int
    -> Data.Binary.Get.Internal.Get Data.ByteString.Internal.ByteString
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,U(U,U,U,U)><L,C(C1(U))>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (n :: GHC.Types.Int) ->
                 case GHC.Classes.gtInt n (GHC.Types.I# 0#) of wild {
                   GHC.Types.False
                   -> Data.Binary.Get.Internal.$fAlternativeGet_$cpure
                        @ Data.ByteString.Internal.ByteString
                        Data.ByteString.empty
                   GHC.Types.True
                   -> Data.Binary.Get.Internal.readN
                        @ Data.ByteString.Internal.ByteString
                        n
                        (Data.ByteString.Unsafe.unsafeTake n) }) -}
77db72247a67480177d8cf9f7750bae6
  getBytes ::
    GHC.Types.Int
    -> Data.Binary.Get.Internal.Get Data.ByteString.Internal.ByteString
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,U(U,U,U,U)><L,C(C1(U))>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Binary.Get.Internal.getByteString -}
05f77d631baec96009d66a9dbb818fb3
  isEmpty :: Data.Binary.Get.Internal.Get GHC.Types.Bool
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.isEmpty1
                  `cast`
                (Sym (Data.Binary.Get.Internal.N:Get[0] <GHC.Types.Bool>_R)) -}
7c122194a6a4cb88ab983c98ff7185d3
  isEmpty1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success GHC.Types.Bool r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success GHC.Types.Bool r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Data.Binary.Get.Internal.$wisEmpty @ r ww1 ww2 ww3 ww4 w1 }) -}
17a0a3c941061de3d388a7b9bb2f41b0
  isolate ::
    GHC.Types.Int
    -> Data.Binary.Get.Internal.Get a -> Data.Binary.Get.Internal.Get a
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,1*C1(C1(U))>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Types.Int)
                   (w1 :: Data.Binary.Get.Internal.Get a) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Binary.Get.Internal.$wisolate @ a ww1 w1 }) -}
938309c54d14c915337ab78bbd67b0aa
  label ::
    GHC.Base.String
    -> Data.Binary.Get.Internal.Get a -> Data.Binary.Get.Internal.Get a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.label1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R <Data.Binary.Get.Internal.Get a>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R)) -}
e07c3d9886defbd6e53ecbc1d27928e9
  label1 ::
    GHC.Base.String
    -> Data.Binary.Get.Internal.Get a
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success a r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ a
                   (msg :: GHC.Base.String)
                   (decoder :: Data.Binary.Get.Internal.Get a)
                   @ r
                   (inp :: Data.ByteString.Internal.ByteString)
                   (ks :: Data.Binary.Get.Internal.Success a r) ->
                 let {
                   lvl13 :: [GHC.Types.Char]
                   = GHC.CString.unpackAppendCString#
                       Data.Binary.Get.Internal.label2
                       msg
                 } in
                 letrec {
                   go :: Data.Binary.Get.Internal.Decoder a
                         -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (r1 :: Data.Binary.Get.Internal.Decoder a) ->
                     case r1 of wild {
                       Data.Binary.Get.Internal.Fail inp' s
                       -> Data.Binary.Get.Internal.Fail
                            @ r
                            inp'
                            (GHC.Base.++ @ GHC.Types.Char s lvl13)
                       Data.Binary.Get.Internal.Partial k
                       -> Data.Binary.Get.Internal.Partial
                            @ r
                            (\ (x :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString) ->
                             go (k x))
                       Data.Binary.Get.Internal.Done inp' a1 -> ks inp' a1
                       Data.Binary.Get.Internal.BytesRead dt k
                       -> Data.Binary.Get.Internal.BytesRead
                            @ r
                            dt
                            (\ (x :: GHC.Int.Int64) -> go (k x)) }
                 } in
                 go
                   (decoder `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                      @ a
                      inp
                      (Data.Binary.Get.Internal.$WDone @ a))) -}
942d73a0b13b4cd9771e2203eeb18b88
  label2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\n"#) -}
b6c88a0968c7c4c1d176bac527fb0ac8
  lookAhead ::
    Data.Binary.Get.Internal.Get a -> Data.Binary.Get.Internal.Get a
  {- Arity: 3, Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.lookAhead1
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Binary.Get.Internal.Get a>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R)) -}
37f25b7d3aac26dcd10dff61f0fa1d1e
  lookAhead1 ::
    Data.Binary.Get.Internal.Get a
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success a r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 3, Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ a
                   (g :: Data.Binary.Get.Internal.Get a)
                   @ r
                   (eta :: Data.ByteString.Internal.ByteString)
                   (eta1 :: Data.Binary.Get.Internal.Success a r) ->
                 letrec {
                   go :: [Data.ByteString.Internal.ByteString]
                         -> Data.Binary.Get.Internal.Decoder a
                         -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (acc :: [Data.ByteString.Internal.ByteString])
                       (r1 :: Data.Binary.Get.Internal.Decoder a) ->
                     case acc of acc1 { DEFAULT ->
                     case r1 of wild {
                       Data.Binary.Get.Internal.Fail inp' s
                       -> Data.Binary.Get.Internal.Fail @ r inp' s
                       Data.Binary.Get.Internal.Partial k
                       -> let {
                            lvl13 :: Data.Binary.Get.Internal.Decoder r
                            = go
                                acc1
                                (k (GHC.Maybe.Nothing @ Data.ByteString.Internal.ByteString))
                          } in
                          Data.Binary.Get.Internal.Partial
                            @ r
                            (\ (minp :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString) ->
                             case minp of wild1 {
                               GHC.Maybe.Nothing -> lvl13
                               GHC.Maybe.Just x
                               -> go
                                    (GHC.Types.: @ Data.ByteString.Internal.ByteString x acc1)
                                    (k wild1) })
                       Data.Binary.Get.Internal.Done inp' a1
                       -> case GHC.List.reverse1
                                 @ Data.ByteString.Internal.ByteString
                                 acc1
                                 (GHC.Types.[] @ Data.ByteString.Internal.ByteString) of wild1 {
                            [] -> eta1 eta a1
                            : ipv ipv1
                            -> eta1
                                 (Data.ByteString.concat
                                    (GHC.Types.: @ Data.ByteString.Internal.ByteString eta wild1))
                                 a1 }
                       Data.Binary.Get.Internal.BytesRead dt k
                       -> Data.Binary.Get.Internal.BytesRead
                            @ r
                            dt
                            (\ (x :: GHC.Int.Int64) -> go acc1 (k x)) } }
                 } in
                 go
                   (GHC.Types.[] @ Data.ByteString.Internal.ByteString)
                   (g `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                      @ a
                      eta
                      (Data.Binary.Get.Internal.$WDone @ a))) -}
d74ae2679fd95d7262004238c7c5fe25
  lookAheadE ::
    Data.Binary.Get.Internal.Get (Data.Either.Either a b)
    -> Data.Binary.Get.Internal.Get (Data.Either.Either a b)
  {- Arity: 3, Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.lookAheadE1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Data.Binary.Get.Internal.Get (Data.Either.Either a b)>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0]
                               <Data.Either.Either a b>_R)) -}
3c5bc0778961159bf63bd63b1182963f
  lookAheadE1 ::
    Data.Binary.Get.Internal.Get (Data.Either.Either a b)
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success (Data.Either.Either a b) r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 3, Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ a
                   @ b
                   (g :: Data.Binary.Get.Internal.Get (Data.Either.Either a b))
                   @ r
                   (eta :: Data.ByteString.Internal.ByteString)
                   (eta1 :: Data.Binary.Get.Internal.Success
                              (Data.Either.Either a b) r) ->
                 letrec {
                   go :: [Data.ByteString.Internal.ByteString]
                         -> Data.Binary.Get.Internal.Decoder (Data.Either.Either a b)
                         -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (acc :: [Data.ByteString.Internal.ByteString])
                       (r1 :: Data.Binary.Get.Internal.Decoder
                                (Data.Either.Either a b)) ->
                     case acc of acc1 { DEFAULT ->
                     case r1 of wild {
                       Data.Binary.Get.Internal.Fail inp s
                       -> Data.Binary.Get.Internal.Fail @ r inp s
                       Data.Binary.Get.Internal.Partial k
                       -> let {
                            lvl13 :: Data.Binary.Get.Internal.Decoder r
                            = go
                                acc1
                                (k (GHC.Maybe.Nothing @ Data.ByteString.Internal.ByteString))
                          } in
                          Data.Binary.Get.Internal.Partial
                            @ r
                            (\ (minp :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString) ->
                             case minp of wild1 {
                               GHC.Maybe.Nothing -> lvl13
                               GHC.Maybe.Just x
                               -> go
                                    (GHC.Types.: @ Data.ByteString.Internal.ByteString x acc1)
                                    (k wild1) })
                       Data.Binary.Get.Internal.Done ds ds1
                       -> case ds1 of wild1 {
                            Data.Either.Left x
                            -> case GHC.List.reverse1
                                      @ Data.ByteString.Internal.ByteString
                                      acc1
                                      (GHC.Types.[]
                                         @ Data.ByteString.Internal.ByteString) of wild2 {
                                 [] -> eta1 eta wild1
                                 : ipv ipv1
                                 -> eta1
                                      (Data.ByteString.concat
                                         (GHC.Types.:
                                            @ Data.ByteString.Internal.ByteString
                                            eta
                                            wild2))
                                      wild1 }
                            Data.Either.Right x -> eta1 ds wild1 }
                       Data.Binary.Get.Internal.BytesRead dt k
                       -> Data.Binary.Get.Internal.BytesRead
                            @ r
                            dt
                            (\ (x :: GHC.Int.Int64) -> go acc1 (k x)) } }
                 } in
                 go
                   (GHC.Types.[] @ Data.ByteString.Internal.ByteString)
                   (g `cast`
                    (Data.Binary.Get.Internal.N:Get[0] <Data.Either.Either a b>_R)
                      @ (Data.Either.Either a b)
                      eta
                      (Data.Binary.Get.Internal.$WDone @ (Data.Either.Either a b)))) -}
0c4bb3a043b64ab81f99fcf2d7a593ae
  lookAheadM ::
    Data.Binary.Get.Internal.Get (GHC.Maybe.Maybe a)
    -> Data.Binary.Get.Internal.Get (GHC.Maybe.Maybe a)
  {- Arity: 3, Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.lookAheadM1
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Binary.Get.Internal.Get (GHC.Maybe.Maybe a)>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0]
                               <GHC.Maybe.Maybe a>_R)) -}
068f59d344a53c10b4b7b83674d69546
  lookAheadM1 ::
    Data.Binary.Get.Internal.Get (GHC.Maybe.Maybe a)
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success (GHC.Maybe.Maybe a) r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 3, Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ a
                   (g :: Data.Binary.Get.Internal.Get (GHC.Maybe.Maybe a))
                   @ r
                   (eta :: Data.ByteString.Internal.ByteString)
                   (eta1 :: Data.Binary.Get.Internal.Success (GHC.Maybe.Maybe a) r) ->
                 Data.Binary.Get.Internal.lookAheadE1
                   @ ()
                   @ a
                   (\ @ r1
                      (i :: Data.ByteString.Internal.ByteString)[OneShot]
                      (ks :: Data.Binary.Get.Internal.Success
                               (Data.Either.Either () a) r1)[OneShot] ->
                    g `cast` (Data.Binary.Get.Internal.N:Get[0] <GHC.Maybe.Maybe a>_R)
                      @ r1
                      i
                      (\ (i' :: Data.ByteString.Internal.ByteString)
                         (a1 :: GHC.Maybe.Maybe a) ->
                       ks
                         i'
                         (case a1 of wild {
                            GHC.Maybe.Nothing -> Data.Binary.Get.Internal.lookAheadM2 @ a
                            GHC.Maybe.Just x -> Data.Either.Right @ () @ a x })))
                     `cast`
                   (Sym (Data.Binary.Get.Internal.N:Get[0]
                             <Data.Either.Either () a>_R))
                   @ r
                   eta
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: Data.Either.Either () a)[OneShot] ->
                    eta1
                      i'
                      (case a1 of wild {
                         Data.Either.Left x -> GHC.Maybe.Nothing @ a
                         Data.Either.Right y -> GHC.Maybe.Just @ a y }))) -}
2c26108dafaab70f67cfe9233b565ef3
  lookAheadM2 :: Data.Either.Either () a
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (\ @ a -> Data.Either.Left @ () @ a GHC.Tuple.()) -}
dd13023f7b86255038d4c73723f537ed
  put ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Get ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,A><C(C(S)),1*C1(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.put1
                  `cast`
                (<Data.ByteString.Internal.ByteString>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <()>_R)) -}
e4a6737b9cb2eee69f789d80ebb88e2b
  put1 ::
    Data.ByteString.Internal.ByteString
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success () r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,A><C(C(S)),1*C1(C1(U))>,
     Unfolding: InlineRule (3, True, True)
                (\ (s :: Data.ByteString.Internal.ByteString)
                   @ r
                   (_inp :: Data.ByteString.Internal.ByteString)
                   (ks :: Data.Binary.Get.Internal.Success () r) ->
                 ks s GHC.Tuple.()) -}
a186c9537e26c2f269fcb2c351eb0f38
  readN ::
    GHC.Types.Int
    -> (Data.ByteString.Internal.ByteString -> a)
    -> Data.Binary.Get.Internal.Get a
  {- Arity: 4,
     Strictness: <S(S),1*U(U)><L,C(U)><S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0] (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   (n :: GHC.Types.Int)
                   (f :: Data.ByteString.Internal.ByteString -> a) ->
                 case n of n1 { GHC.Types.I# ipv ->
                 let {
                   onFail :: forall a1.
                             [Data.ByteString.Internal.ByteString]
                             -> forall r.
                                Data.ByteString.Internal.ByteString
                                -> Data.Binary.Get.Internal.Success a1 r
                                -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 3 -}
                   = \ @ a1
                       (bss :: [Data.ByteString.Internal.ByteString])
                       @ r
                       (ds :: Data.ByteString.Internal.ByteString)
                       (ds1 :: Data.Binary.Get.Internal.Success a1 r) ->
                     case Data.ByteString.concat
                            bss of dt { Data.ByteString.Internal.PS ipv1 ipv2 ipv3 ipv4 ->
                     Data.Binary.Get.Internal.Fail
                       @ r
                       dt
                       (GHC.CString.unpackCString# "not enough bytes"#) }
                 } in
                 let {
                   onSucc :: [Data.ByteString.Internal.ByteString]
                             -> Data.ByteString.Internal.ByteString
                     {- Arity: 1 -}
                   = \ (x :: [Data.ByteString.Internal.ByteString]) ->
                     Data.ByteString.concat
                       (GHC.List.dropWhile
                          @ Data.ByteString.Internal.ByteString
                          Data.ByteString.null
                          x)
                 } in
                 let {
                   enoughChunks :: GHC.Types.Int
                                   -> Data.ByteString.Internal.ByteString
                                   -> Data.Either.Either
                                        GHC.Types.Int
                                        (Data.ByteString.Internal.ByteString,
                                         Data.ByteString.Internal.ByteString)
                     {- Arity: 2 -}
                   = \ (n2 :: GHC.Types.Int)
                       (str2 :: Data.ByteString.Internal.ByteString) ->
                     case str2 of wild { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                     case n2 of wild1 { GHC.Types.I# y ->
                     case GHC.Prim.>=# dt3 y of lwild {
                       DEFAULT
                       -> Data.Either.Left
                            @ GHC.Types.Int
                            @ (Data.ByteString.Internal.ByteString,
                               Data.ByteString.Internal.ByteString)
                            (GHC.Types.I# (GHC.Prim.-# y dt3))
                       1#
                       -> Data.Either.Right
                            @ GHC.Types.Int
                            @ (Data.ByteString.Internal.ByteString,
                               Data.ByteString.Internal.ByteString)
                            (wild, Data.ByteString.empty) } } }
                 } in
                 (\ @ r
                    (i :: Data.ByteString.Internal.ByteString)
                    (ks :: Data.Binary.Get.Internal.Success a r) ->
                  case i of wild { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                  case GHC.Prim.>=# dt3 ipv of lwild {
                    DEFAULT
                    -> Data.Binary.Get.Internal.readN1
                         @ GHC.Types.Int
                         @ Data.ByteString.Internal.ByteString
                         n1
                         enoughChunks
                         onSucc
                         (onFail @ Data.ByteString.Internal.ByteString)
                           `cast`
                         (<[Data.ByteString.Internal.ByteString]>_R
                          ->_R Sym (Data.Binary.Get.Internal.N:Get[0]
                                        <Data.ByteString.Internal.ByteString>_R))
                         @ r
                         wild
                         (\ (i' :: Data.ByteString.Internal.ByteString)
                            (a1 :: Data.ByteString.Internal.ByteString) ->
                          case f a1 of vx { DEFAULT ->
                          ks
                            (case a1 of wild1 { Data.ByteString.Internal.PS dt4 dt5 dt6 dt7 ->
                             Data.ByteString.Internal.PS
                               dt4
                               dt5
                               (GHC.Prim.+# dt6 ipv)
                               (GHC.Prim.-# dt7 ipv) })
                            vx })
                    1#
                    -> case f wild of vx { DEFAULT ->
                       ks
                         (Data.ByteString.Internal.PS
                            dt
                            dt1
                            (GHC.Prim.+# dt2 ipv)
                            (GHC.Prim.-# dt3 ipv))
                         vx } } })
                   `cast`
                 (Sym (Data.Binary.Get.Internal.N:Get[0] <a>_R)) }) -}
a186c9537e26c2f269fcb2c351eb0f38
  readN1 ::
    s
    -> Data.Binary.Get.Internal.Consume s
    -> ([Data.ByteString.Internal.ByteString] -> b)
    -> ([Data.ByteString.Internal.ByteString]
        -> Data.Binary.Get.Internal.Get b)
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success b r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 6,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,C(U)><L,C(C1(C1(U)))><L,U><L,U>,
     Unfolding: (\ @ s
                   @ b
                   (initS :: s)
                   (consume :: Data.Binary.Get.Internal.Consume s)
                   (onSucc :: [Data.ByteString.Internal.ByteString] -> b)
                   (onFail :: [Data.ByteString.Internal.ByteString]
                              -> Data.Binary.Get.Internal.Get b)
                   @ r
                   (eta :: Data.ByteString.Internal.ByteString)
                   (eta1 :: Data.Binary.Get.Internal.Success b r) ->
                 letrec {
                   go :: s
                         -> [Data.ByteString.Internal.ByteString]
                         -> forall r1.
                            Data.ByteString.Internal.ByteString
                            -> Data.Binary.Get.Internal.Success b r1
                            -> Data.Binary.Get.Internal.Decoder r1
                     {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U> -}
                   = \ (state :: s)
                       (acc :: [Data.ByteString.Internal.ByteString])
                       @ r1
                       (inp :: Data.ByteString.Internal.ByteString)
                       (ks :: Data.Binary.Get.Internal.Success b r1) ->
                     case consume state inp of wild {
                       Data.Either.Left state'
                       -> let {
                            acc' :: [Data.ByteString.Internal.ByteString]
                            = GHC.Types.: @ Data.ByteString.Internal.ByteString inp acc
                          } in
                          let {
                            kf :: Data.Binary.Get.Internal.Decoder r1
                            = (onFail
                                 (GHC.List.reverse1
                                    @ Data.ByteString.Internal.ByteString
                                    acc'
                                    (GHC.Types.[] @ Data.ByteString.Internal.ByteString)))
                                `cast`
                              (Data.Binary.Get.Internal.N:Get[0] <b>_R)
                                @ r1
                                Data.ByteString.empty
                                ks
                          } in
                          letrec {
                            loop :: Data.Binary.Get.Internal.Decoder r1
                            = Data.Binary.Get.Internal.Partial @ r1 loop1
                            loop1 :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString
                                     -> Data.Binary.Get.Internal.Decoder r1
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (sm :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString) ->
                              case sm of wild1 {
                                GHC.Maybe.Nothing -> kf
                                GHC.Maybe.Just s1
                                -> case s1 of wild2 { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                                   case GHC.Prim.<=# dt3 0# of lwild {
                                     DEFAULT -> go state' acc' @ r1 wild2 ks 1# -> loop } } }
                          } in
                          loop
                       Data.Either.Right ds
                       -> case ds of wild1 { (,) want rest ->
                          ks
                            rest
                            (onSucc
                               (GHC.List.reverse1
                                  @ Data.ByteString.Internal.ByteString
                                  (GHC.Types.: @ Data.ByteString.Internal.ByteString want acc)
                                  (GHC.Types.[] @ Data.ByteString.Internal.ByteString))) } }
                 } in
                 go
                   initS
                   (GHC.Types.[] @ Data.ByteString.Internal.ByteString)
                   @ r
                   eta
                   eta1) -}
46675a42f54b9090f7407e8abb3d4de5
  readNWith ::
    GHC.Types.Int
    -> (GHC.Ptr.Ptr a -> GHC.Types.IO a)
    -> Data.Binary.Get.Internal.Get a
  {- Arity: 4,
     Strictness: <S(S),1*U(U)><L,C(C1(U(U,1*U)))><S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   (n :: GHC.Types.Int)
                   (f :: GHC.Ptr.Ptr a -> GHC.Types.IO a) ->
                 Data.Binary.Get.Internal.readN
                   @ a
                   n
                   (\ (s :: Data.ByteString.Internal.ByteString) ->
                    case s of wild { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                    case (f (GHC.Ptr.Ptr
                               @ Foreign.C.Types.CChar
                               (GHC.Prim.plusAddr# dt dt2))
                              `cast`
                            (GHC.Ptr.Ptr
                               Univ(phantom phantom <*>_N :: Foreign.C.Types.CChar, a))_R)
                           `cast`
                         (GHC.Types.N:IO[0] <a>_R)
                           GHC.Prim.realWorld# of ds1 { (#,#) ipv ipv1 ->
                    case GHC.Prim.touch#
                           @ 'GHC.Types.LiftedRep
                           @ GHC.ForeignPtr.ForeignPtrContents
                           dt1
                           ipv of s' { DEFAULT ->
                    ipv1 } } })) -}
ecad5fe3a2f0ecedb4f685f5889839b3
  remaining :: Data.Binary.Get.Internal.Get GHC.Int.Int64
  {- Arity: 2, Strictness: <L,U><L,C(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.remaining1
                  `cast`
                (Sym (Data.Binary.Get.Internal.N:Get[0] <GHC.Int.Int64>_R)) -}
f982e49193d153f3f1d1b974412ec1a3
  remaining1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success GHC.Int.Int64 r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <L,U><L,C(C1(U))>,
     Unfolding: (\ @ r
                   (inp :: Data.ByteString.Internal.ByteString)
                   (ks :: Data.Binary.Get.Internal.Success GHC.Int.Int64 r) ->
                 letrec {
                   loop :: [Data.ByteString.Internal.ByteString]
                           -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (acc :: [Data.ByteString.Internal.ByteString]) ->
                     let {
                       lvl13 :: Data.Binary.Get.Internal.Decoder r
                       = let {
                           all_inp :: Data.ByteString.Internal.ByteString
                           = Data.ByteString.concat
                               (GHC.Types.:
                                  @ Data.ByteString.Internal.ByteString
                                  inp
                                  (GHC.List.reverse @ Data.ByteString.Internal.ByteString acc))
                         } in
                         ks
                           all_inp
                           (case all_inp of wild { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                            GHC.Int.I64# dt3 })
                     } in
                     Data.Binary.Get.Internal.Partial
                       @ r
                       (\ (minp :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString) ->
                        case minp of wild {
                          GHC.Maybe.Nothing -> lvl13
                          GHC.Maybe.Just inp'
                          -> loop
                               (GHC.Types.: @ Data.ByteString.Internal.ByteString inp' acc) })
                 } in
                 loop (GHC.Types.[] @ Data.ByteString.Internal.ByteString)) -}
a186c9537e26c2f269fcb2c351eb0f38
  runCont ::
    Data.Binary.Get.Internal.Get a
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success a r
       -> Data.Binary.Get.Internal.Decoder r
  RecSel Left Data.Binary.Get.Internal.Get
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (dk :: Data.Binary.Get.Internal.Get a) @ r ->
                 dk `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R) @ r) -}
651791b42097319e11d9abd33711e49f
  runGetIncremental ::
    Data.Binary.Get.Internal.Get a
    -> Data.Binary.Get.Internal.Decoder a
  {- Arity: 1, Strictness: <C(C(S)),1*C1(C1(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (g :: Data.Binary.Get.Internal.Get a) ->
                 Data.Binary.Get.Internal.runGetIncremental1
                   @ a
                   (g `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                      @ a
                      Data.ByteString.empty
                      (Data.Binary.Get.Internal.$WDone @ a))) -}
3e58e40185ac7853733f7e81969f61e8
  runGetIncremental1 ::
    Data.Binary.Get.Internal.Decoder a
    -> Data.Binary.Get.Internal.Decoder a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
2596f9c7dc5cd2cce21015127b0c93dd
  withInputChunks ::
    s
    -> Data.Binary.Get.Internal.Consume s
    -> ([Data.ByteString.Internal.ByteString] -> b)
    -> ([Data.ByteString.Internal.ByteString]
        -> Data.Binary.Get.Internal.Get b)
    -> Data.Binary.Get.Internal.Get b
  {- Arity: 6,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,C(U)><L,C(C1(C1(U)))><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Binary.Get.Internal.readN1
                  `cast`
                (forall (s :: <*>_N) (b :: <*>_N).
                 <s>_R
                 ->_R <Data.Binary.Get.Internal.Consume s>_R
                 ->_R <[Data.ByteString.Internal.ByteString] -> b>_R
                 ->_R <[Data.ByteString.Internal.ByteString]
                       -> Data.Binary.Get.Internal.Get b>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0] <b>_R)) -}
instance GHC.Base.Alternative [Data.Binary.Get.Internal.Get]
  = Data.Binary.Get.Internal.$fAlternativeGet
instance GHC.Base.Applicative [Data.Binary.Get.Internal.Get]
  = Data.Binary.Get.Internal.$fApplicativeGet
instance GHC.Base.Functor [Data.Binary.Get.Internal.Decoder]
  = Data.Binary.Get.Internal.$fFunctorDecoder
instance GHC.Base.Functor [Data.Binary.Get.Internal.Get]
  = Data.Binary.Get.Internal.$fFunctorGet
instance Control.Monad.Fail.MonadFail [Data.Binary.Get.Internal.Get]
  = Data.Binary.Get.Internal.$fMonadFailGet
instance GHC.Base.Monad [Data.Binary.Get.Internal.Get]
  = Data.Binary.Get.Internal.$fMonadGet
instance GHC.Base.MonadPlus [Data.Binary.Get.Internal.Get]
  = Data.Binary.Get.Internal.$fMonadPlusGet
instance GHC.Show.Show [Data.Binary.Get.Internal.Decoder]
  = Data.Binary.Get.Internal.$fShowDecoder
"readN/readN merge" forall @ a
                           @ a1
                           (n :: GHC.Types.Int)
                           (m :: GHC.Types.Int)
                           (f :: Data.ByteString.Internal.ByteString -> a1 -> a)
                           (g :: Data.ByteString.Internal.ByteString -> a1)
  Data.Binary.Get.Internal.apG @ a1
                               @ a
                               (Data.Binary.Get.Internal.readN @ (a1 -> a) n f)
                               (Data.Binary.Get.Internal.readN @ a1 m g)
  = Data.Binary.Get.Internal.readN
      @ a
      (GHC.Num.$fNumInt_$c+ n m)
      (\ (bs :: Data.ByteString.Internal.ByteString) ->
       GHC.Base.$
         @ 'GHC.Types.LiftedRep
         @ a1
         @ a
         (f bs)
         (g (Data.ByteString.Unsafe.unsafeDrop n bs)))
Warnings remaining "This will force all remaining input, don't use it."
         getBytes "Use 'getByteString' instead of 'getBytes'."
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

